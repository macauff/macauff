<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>macauff.perturbation_auf &#8212; macauff</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=4848ba22" />
    <link rel="stylesheet" type="text/css" href="../../_static/pyramid.css?v=a5b9c134" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../f-modindex.html" title="Fortran Module Index"
             >fortran modules</a> |</li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">macauff</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">macauff.perturbation_auf</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for macauff.perturbation_auf</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">This module provides the framework to handle the creation of the perturbation</span>
<span class="sd">component of the astrometric uncertainty function.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy.coordinates</span> <span class="kn">import</span> <span class="n">SkyCoord</span>

<span class="kn">from</span> <span class="nn">.misc_functions</span> <span class="kn">import</span> <span class="p">(</span><span class="n">create_auf_params_grid</span><span class="p">,</span> <span class="n">_load_rectangular_slice</span><span class="p">,</span> <span class="n">min_max_lon</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.misc_functions_fortran</span> <span class="kn">import</span> <span class="n">misc_functions_fortran</span> <span class="k">as</span> <span class="n">mff</span>
<span class="kn">from</span> <span class="nn">.get_trilegal_wrapper</span> <span class="kn">import</span> <span class="n">get_trilegal</span><span class="p">,</span> <span class="n">get_AV_infinity</span>
<span class="kn">from</span> <span class="nn">.perturbation_auf_fortran</span> <span class="kn">import</span> <span class="n">perturbation_auf_fortran</span> <span class="k">as</span> <span class="n">paf</span>
<span class="kn">from</span> <span class="nn">.galaxy_counts</span> <span class="kn">import</span> <span class="n">create_galaxy_counts</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;make_perturb_aufs&#39;</span><span class="p">,</span> <span class="s1">&#39;create_single_perturb_auf&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="make_perturb_aufs">
<a class="viewcode-back" href="../../api/macauff.make_perturb_aufs.html#macauff.make_perturb_aufs">[docs]</a>
<span class="k">def</span> <span class="nf">make_perturb_aufs</span><span class="p">(</span><span class="n">auf_folder</span><span class="p">,</span> <span class="n">cat_folder</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">auf_points</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span>
                      <span class="n">drho</span><span class="p">,</span> <span class="n">which_cat</span><span class="p">,</span> <span class="n">include_perturb_auf</span><span class="p">,</span> <span class="n">tri_download_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">delta_mag_cuts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">psf_fwhms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tri_set_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tri_filt_num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">tri_filt_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tri_maglim_faint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tri_num_faint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">auf_region_frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_trials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">j0s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d_mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">density_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">run_fw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">run_psf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dd_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l_cut</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">snr_mag_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">al_avs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_gal_flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmau_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">wavs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z_maxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nzs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ab_offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">alpha0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to perform the creation of the blended object perturbation component</span>
<span class="sd">    of the AUF.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    auf_folder : string</span>
<span class="sd">        The overall folder into which to create filter-pointing folders and save</span>
<span class="sd">        individual simulation files.</span>
<span class="sd">    cat_folder : string</span>
<span class="sd">        The folder that the photometric catalogue being simulated for perturbation</span>
<span class="sd">        AUF component is stored in.</span>
<span class="sd">    filters : list of strings or numpy.ndarray of strings</span>
<span class="sd">        An array containing the list of filters in this catalogue to create</span>
<span class="sd">        simulated AUF components for.</span>
<span class="sd">    auf_points : numpy.ndarray</span>
<span class="sd">        Two-dimensional array containing pairs of coordinates at which to evaluate</span>
<span class="sd">        the perturbation AUF components.</span>
<span class="sd">    r : numpy.ndarray</span>
<span class="sd">        The real-space coordinates for the Hankel transformations used in AUF-AUF</span>
<span class="sd">        convolution.</span>
<span class="sd">    dr : numpy.ndarray</span>
<span class="sd">        The spacings between ``r`` elements.</span>
<span class="sd">    rho : numpy.ndarray</span>
<span class="sd">        The fourier-space coordinates for Hankel transformations.</span>
<span class="sd">    drho : numpy.ndarray</span>
<span class="sd">        The spacings between ``rho`` elements.</span>
<span class="sd">    which_cat : string</span>
<span class="sd">        Indicator as to whether these perturbation AUFs are for catalogue &quot;a&quot;</span>
<span class="sd">        or catalogue &quot;b&quot; within the cross-match process.</span>
<span class="sd">    include_perturb_auf : boolean</span>
<span class="sd">        ``True`` or ``False`` flag indicating whether perturbation component of the</span>
<span class="sd">        AUF should be used or not within the cross-match process.</span>
<span class="sd">    tri_download_flag : boolean, optional</span>
<span class="sd">        A ``True``/``False`` flag, whether to re-download TRILEGAL simulated star</span>
<span class="sd">        counts or not if a simulation already exists in a given folder. Only</span>
<span class="sd">        needed if ``include_perturb_auf`` is True.</span>
<span class="sd">    delta_mag_cuts : numpy.ndarray, optional</span>
<span class="sd">        Array of magnitude offsets corresponding to relative fluxes of perturbing</span>
<span class="sd">        sources, for consideration of relative contamination chances. Must be given</span>
<span class="sd">        if ``include_perturb_auf`` is ``True``.</span>
<span class="sd">    psf_fwhms : numpy.ndarray, optional</span>
<span class="sd">        Array of full width at half-maximums for each filter in ``filters``. Only</span>
<span class="sd">        required if ``include_perturb_auf`` is True; defaults to ``None``.</span>
<span class="sd">    tri_set_name : string, optional</span>
<span class="sd">        Name of the filter set to generate simulated TRILEGAL Galactic source</span>
<span class="sd">        counts from. If ``include_perturb_auf`` is ``True``, this must be set.</span>
<span class="sd">    tri_filt_num : string, optional</span>
<span class="sd">        Column number of the filter defining the magnitude limit of simulated</span>
<span class="sd">        TRILEGAL Galactic sources. If ``include_perturb_auf`` is ``True``, this</span>
<span class="sd">        must be set.</span>
<span class="sd">    tri_filt_names : list or array of strings, optional</span>
<span class="sd">        List of filter names in the TRILEGAL filterset defined in ``tri_set_name``,</span>
<span class="sd">        in the same order as provided in ``psf_fwhms``. If ``include_perturb_auf``</span>
<span class="sd">        is ``True``, this must be set.</span>
<span class="sd">    tri_maglim_faint : float</span>
<span class="sd">        Magnitude in the primary TRILEGAL filter to simulate sources down to for</span>
<span class="sd">        the main, &quot;faint&quot; simulation, used to capture the differential source</span>
<span class="sd">        counts at all appropriate magnitudes. If ``include_perturb_auf`` is</span>
<span class="sd">        ``True``, this must be set.</span>
<span class="sd">    tri_num_faint : integer</span>
<span class="sd">        Number of objects to simulate in the main TRILEGAL simulation. Should</span>
<span class="sd">        capture sufficient numbers to be accurate without overrunning simulation</span>
<span class="sd">        times. If ``include_perturb_auf`` is ``True``, this must be set.</span>
<span class="sd">    auf_region_frame : string, optional</span>
<span class="sd">        Coordinate reference frame in which sky coordinates are defined, either</span>
<span class="sd">        ``equatorial`` or ``galactic``, used to define the coordinates TRILEGAL</span>
<span class="sd">        simulations are generated in. If ``include_perturb_auf`` is ``True``,</span>
<span class="sd">        this must be set.</span>
<span class="sd">    num_trials : integer, optional</span>
<span class="sd">        The number of simulated PSFs to compute in the derivation of the</span>
<span class="sd">        perturbation component of the AUF. Must be given if ``include_perturb_auf``</span>
<span class="sd">        is ``True``.</span>
<span class="sd">    j0s : numpy.ndarray, optional</span>
<span class="sd">        The Bessel Function of First Kind of Zeroth Order evaluated at each</span>
<span class="sd">        ``r``-``rho`` combination. Must be given if ``include_perturb_auf``</span>
<span class="sd">        is ``True``.</span>
<span class="sd">    d_mag : float, optional</span>
<span class="sd">        The resolution at which to create the TRILEGAL source density distribution.</span>
<span class="sd">        Must be provided if ``include_perturb_auf`` is ``True``.</span>
<span class="sd">    density_radius : float, optional</span>
<span class="sd">        The astrometric distance, in degrees, within which to consider numbers</span>
<span class="sd">        of internal catalogue sources, from which to calculate local density.</span>
<span class="sd">        Must be given if ``include_perturb_auf`` is ``True``.</span>
<span class="sd">    run_fw : bool, optional</span>
<span class="sd">        Flag indicating whether to run the &quot;flux-weighted&quot; version of the</span>
<span class="sd">        perturbation algorithm. Must be given if ``include_perturb_auf`` is</span>
<span class="sd">        ``True``.</span>
<span class="sd">    run_psf : bool, optional</span>
<span class="sd">        Flag indicating whether to run the &quot;background-dominated PSF&quot; version</span>
<span class="sd">        of the perturbation algorithm. Must be given if ``include_perturb_auf``</span>
<span class="sd">        is ``True``.</span>
<span class="sd">    dd_params : numpy.ndarray, optional</span>
<span class="sd">        Polynomial fits for the various parameters controlling the background</span>
<span class="sd">        limited PSF-fit algorithm for centroid perturbations. Must be given if</span>
<span class="sd">        ``include_perturb_auf`` is ``True`` and ``run_psf`` is ``True``.</span>
<span class="sd">    l_cut : numpy.ndarray or list, optional</span>
<span class="sd">        Relative flux cutoffs for which algorithm to use in the background</span>
<span class="sd">        limited PSF-fit algorithm case. Must be given if ``include_perturb_auf``</span>
<span class="sd">        is ``True`` and ``run_psf`` is ``True``.</span>
<span class="sd">    snr_mag_params : numpy.ndarray, optional</span>
<span class="sd">        Array, of shape ``(X, Y, 5)``, containing the pre-determined values of the</span>
<span class="sd">        magnitude-perturbation weighting relationship for a series of Galactic</span>
<span class="sd">        sightlines for each ``filters`` filter. Must be given if</span>
<span class="sd">        ``include_perturb_auf`` is ``True``.</span>
<span class="sd">    al_avs : list of numpy.ndarray or numpy.ndarray, optional</span>
<span class="sd">        Relative extinction curve vectors for each filter in ``filters``,</span>
<span class="sd">        :math:`\frac{A_\lambda}{A_V}`, to convert exinction in the V-band</span>
<span class="sd">        to extinction in the relevant filter. Must be given if</span>
<span class="sd">        ``include_perturb_auf`` is ``True``.</span>
<span class="sd">    fit_gal_flag : boolean, optional</span>
<span class="sd">        Flag indicating whether to include galaxy counts in derivations of</span>
<span class="sd">        perturbation component of the AUF. Must be given if</span>
<span class="sd">        ``include_perturb_auf`` is ``True``.</span>
<span class="sd">    cmau_array : numpy.ndarray, optional</span>
<span class="sd">        Array of shape ``(5, 2, 4)`` holding the Wilson (2022, RNAAS, 6, 60) [1]_</span>
<span class="sd">        c, m, a, and u values that describe the Schechter parameterisation with</span>
<span class="sd">        wavelength.</span>
<span class="sd">    wavs : list of floats or numpy.ndarray, optional</span>
<span class="sd">        List of central wavelengths of each filter in ``filters``, used to</span>
<span class="sd">        compute appropriate Schechter function parameters for fitting galaxy</span>
<span class="sd">        counts. Must be given if ``include_perturb_auf`` and ``fit_gal_flag``</span>
<span class="sd">        are ``True``.</span>
<span class="sd">    z_maxs : list of floats or numpy.ndarray, optional</span>
<span class="sd">        List of maximum redshifts to compute galaxy densities out to when</span>
<span class="sd">        deriving Schechter functions. Must be given if ``include_perturb_auf``</span>
<span class="sd">        and ``fit_gal_flag`` are ``True``.</span>
<span class="sd">    nzs : list of integers or numpy.ndarray, optional</span>
<span class="sd">        Resolution of redshift grid, in the sense of ``np.linspace(0, z_max, nz)``,</span>
<span class="sd">        to evaluate Schechter functions on. Must be given if</span>
<span class="sd">        ``include_perturb_auf`` and ``fit_gal_flag`` are ``True``.</span>
<span class="sd">    ab_offsets : list of floats or numpy.ndarray, optional</span>
<span class="sd">        For filters in a non-AB magnitude system, the given offset between</span>
<span class="sd">        the chosen filter system and AB magnitudes, in the sense of m = m_AB -</span>
<span class="sd">        ab_offset. Must be given if ``include_perturb_auf`` and ``fit_gal_flag``</span>
<span class="sd">        are ``True``.</span>
<span class="sd">    filter_names : list of string, optional</span>
<span class="sd">        Names for each filter in ``filters`` in a ``speclite``-appropriate</span>
<span class="sd">        naming scheme (``group_name``-``band_name``), for loading response</span>
<span class="sd">        curves to calculate galaxy k-corrections. Must be given if</span>
<span class="sd">        ``include_perturb_auf`` and ``fit_gal_flag`` are ``True``.</span>
<span class="sd">    alpha0 : list of numpy.ndarray or numpy.ndarray, optional</span>
<span class="sd">        Indices used to calculate parameters :math:`\alpha_i`, used in deriving</span>
<span class="sd">        Dirichlet-distributed SED coefficients. :math:`\alpha{i, 0}` are the</span>
<span class="sd">        zero-redshift parameters; see [2]_ and [3]_ for more details.</span>
<span class="sd">    alpha1 : list of numpy.ndarray or numpy.ndarray, optional</span>
<span class="sd">        :math:`\alpha_{i, 1}`, indices at redshift z=1 used to derive</span>
<span class="sd">        Dirichlet-distributed SED coefficient values :math:`\alpha_i`.</span>
<span class="sd">    alpha_weight : list of numpy.ndarray or numpy.ndarray, optional</span>
<span class="sd">        Weights for use in calculating :math:`\alpha_i` from ``alpha0`` and</span>
<span class="sd">        ``alpha1``.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wilson T. J. (2022), RNAAS, 6, 60</span>
<span class="sd">    .. [2] Herbel J., Kacprzak T., Amara A., et al. (2017), JCAP, 8, 35</span>
<span class="sd">    .. [3] Blanton M. R., Roweis S. (2007), AJ, 133, 734</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">tri_set_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tri_set_name must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">tri_filt_num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tri_filt_num must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">tri_filt_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tri_filt_names must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">tri_maglim_faint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tri_maglim_faint must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">tri_num_faint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tri_num_faint must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">auf_region_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;auf_region_frame must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">delta_mag_cuts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;delta_mag_cuts must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">psf_fwhms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;psf_fwhms must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">num_trials</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_trials must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">j0s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;j0s must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">d_mag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;d_mag must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">run_fw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;run_fw must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">run_psf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;run_psf must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">run_psf</span> <span class="ow">and</span> <span class="n">dd_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dd_params must be given if include_perturb_auf and run_psf are True.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">dd_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Fake an array to pass only to run_fw that fortran will accept:</span>
        <span class="n">dd_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">run_psf</span> <span class="ow">and</span> <span class="n">l_cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;l_cut must be given if include_perturb_auf and run_psf are True.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">l_cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Fake an array to pass only to run_fw that fortran will accept:</span>
        <span class="n">l_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">snr_mag_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;snr_mag_params must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">al_avs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;al_avs must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">density_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;density_radius must be given if include_perturb_auf is True.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fit_gal_flag must not be None if include_perturb_auf is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">and</span> <span class="n">cmau_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cmau_array must be given if fit_gal_flag is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">and</span> <span class="n">wavs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wavs must be given if fit_gal_flag is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">and</span> <span class="n">z_maxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z_maxs must be given if fit_gal_flag is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">and</span> <span class="n">nzs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nzs must be given if fit_gal_flag is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">and</span> <span class="n">ab_offsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ab_offsets must be given if fit_gal_flag is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">and</span> <span class="n">filter_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;filter_names must be given if fit_gal_flag is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">and</span> <span class="n">alpha0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha0 must be given if fit_gal_flag is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">and</span> <span class="n">alpha1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha1 must be given if fit_gal_flag is True.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="n">fit_gal_flag</span> <span class="ow">and</span> <span class="n">alpha_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha_weight must be given if fit_gal_flag is True.&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating perturbation AUFs sky indices for catalogue &quot;</span><span class="si">{}</span><span class="s1">&quot;...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">which_cat</span><span class="p">))</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="n">a_tot_astro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/con_cat_astro.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cat_folder</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">include_perturb_auf</span><span class="p">:</span>
        <span class="n">a_tot_photo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/con_cat_photo.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cat_folder</span><span class="p">))</span>

    <span class="n">n_sources</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_tot_astro</span><span class="p">)</span>

    <span class="n">modelrefinds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_sources</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>

    <span class="c1"># Which sky position to use is more complex; this involves determining</span>
    <span class="c1"># the smallest great-circle distance to each auf_point AUF mapping for</span>
    <span class="c1"># each source.</span>
    <span class="n">modelrefinds</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mff</span><span class="o">.</span><span class="n">find_nearest_point</span><span class="p">(</span><span class="n">a_tot_astro</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">a_tot_astro</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                                                <span class="n">auf_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">auf_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating empirical perturbation AUFs for catalogue &quot;</span><span class="si">{}</span><span class="s1">&quot;...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">which_cat</span><span class="p">))</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="c1"># Store the length of the density-magnitude combinations in each sky/filter</span>
    <span class="c1"># combination for future loading purposes.</span>
    <span class="n">arraylengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filters</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">auf_points</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_perturb_auf</span><span class="p">:</span>
        <span class="n">local_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_tot_astro</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">filters</span><span class="p">)))</span>

    <span class="n">perturb_auf_outputs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">auf_points</span><span class="p">)):</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">auf_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ax_folder</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">auf_folder</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ax_folder</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">ax_folder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">include_perturb_auf</span><span class="p">:</span>
            <span class="n">sky_cut</span> <span class="o">=</span> <span class="n">modelrefinds</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">i</span>
            <span class="n">med_index_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_N</span><span class="p">))[</span><span class="n">sky_cut</span><span class="p">]</span>
            <span class="n">a_photo_cut</span> <span class="o">=</span> <span class="n">a_tot_photo</span><span class="p">[</span><span class="n">sky_cut</span><span class="p">]</span>
            <span class="n">a_astro_cut</span> <span class="o">=</span> <span class="n">a_tot_astro</span><span class="p">[</span><span class="n">sky_cut</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_astro_cut</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax1_min</span><span class="p">,</span> <span class="n">ax1_max</span> <span class="o">=</span> <span class="n">min_max_lon</span><span class="p">(</span><span class="n">a_astro_cut</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">ax2_min</span><span class="p">,</span> <span class="n">ax2_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a_astro_cut</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a_astro_cut</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

                <span class="n">dens_mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filters</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dens_mags</span><span class="p">)):</span>
                    <span class="c1"># Take the &quot;density&quot; magnitude (i.e., the faint limit down to</span>
                    <span class="c1"># which to integrate counts per square degree per magnitude) from</span>
                    <span class="c1"># the data, with a small allowance for completeness limit turnover.</span>
                    <span class="n">hist</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a_photo_cut</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a_photo_cut</span><span class="p">)],</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
                    <span class="c1"># TODO: relax half-mag cut, make input parameter</span>
                    <span class="n">dens_mags</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">hist</span><span class="p">)]</span> <span class="o">-</span> <span class="mf">0.5</span>

        <span class="c1"># If there are no sources in this entire section of sky, we don&#39;t need</span>
        <span class="c1"># to bother downloading any TRILEGAL simulations since we&#39;ll auto-fill</span>
        <span class="c1"># dummy data (and never use it) in the filter loop.</span>
        <span class="k">if</span> <span class="n">include_perturb_auf</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_astro_cut</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">tri_download_flag</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/trilegal_auf_simulation_faint.dat&#39;</span>
                                                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax_folder</span><span class="p">))):</span>
            <span class="c1"># Currently assume that the area of each small patch is a rectangle</span>
            <span class="c1"># on the sky, implicitly assuming that the large region is also a</span>
            <span class="c1"># rectangle, after any spherical projection cos(delta) effects.</span>
            <span class="n">rect_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax1_max</span> <span class="o">-</span> <span class="n">ax1_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ax2_max</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ax2_min</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

            <span class="n">data_bright_dens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a_photo_cut</span><span class="p">[:,</span> <span class="n">q</span><span class="p">])</span> <span class="o">&amp;</span>
                                         <span class="p">(</span><span class="n">a_photo_cut</span><span class="p">[:,</span> <span class="n">q</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dens_mags</span><span class="p">[</span><span class="n">q</span><span class="p">]))</span> <span class="o">/</span> <span class="n">rect_area</span>
                                        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dens_mags</span><span class="p">))])</span>
            <span class="c1"># TODO: un-hardcode min_bright_tri_number</span>
            <span class="n">min_bright_tri_number</span> <span class="o">=</span> <span class="mi">1000</span>
            <span class="n">min_area</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_bright_tri_number</span> <span class="o">/</span> <span class="n">data_bright_dens</span><span class="p">)</span>
            <span class="c1"># Hard-coding the AV=1 trick to allow for using av_grid later.</span>
            <span class="n">download_trilegal_simulation</span><span class="p">(</span><span class="n">ax_folder</span><span class="p">,</span> <span class="n">tri_set_name</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">tri_filt_num</span><span class="p">,</span>
                                         <span class="n">auf_region_frame</span><span class="p">,</span> <span class="n">tri_maglim_faint</span><span class="p">,</span> <span class="n">min_area</span><span class="p">,</span>
                                         <span class="n">AV</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma_AV</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_objs</span><span class="o">=</span><span class="n">tri_num_faint</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;mv </span><span class="si">{}</span><span class="s1">/trilegal_auf_simulation.dat </span><span class="si">{}</span><span class="s1">/trilegal_auf_simulation_faint.dat&#39;</span>
                      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax_folder</span><span class="p">,</span> <span class="n">ax_folder</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filters</span><span class="p">)):</span>
            <span class="n">perturb_auf_combo</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">filters</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">include_perturb_auf</span><span class="p">:</span>
                <span class="n">good_mag_slice</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a_photo_cut</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">a_photo</span> <span class="o">=</span> <span class="n">a_photo_cut</span><span class="p">[</span><span class="n">good_mag_slice</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_photo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">arraylengths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># If no sources in this AUF-filter combination, we need to</span>
                    <span class="c1"># fake some dummy variables for use in the 3/4-D grids below.</span>
                    <span class="c1"># See below, in include_perturb_auf is False, for meanings.</span>
                    <span class="n">num_N_mag</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">Frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_N_mag</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                    <span class="n">Flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_N_mag</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_N_mag</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                    <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_N_mag</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                    <span class="n">fourieroffset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_N_mag</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                    <span class="n">Narray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
                    <span class="n">magarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
                    <span class="c1"># Make a second dictionary with the single pointing-filter</span>
                    <span class="c1"># combination in it.</span>
                    <span class="n">single_perturb_auf_output</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                            <span class="p">[</span><span class="s1">&#39;frac&#39;</span><span class="p">,</span> <span class="s1">&#39;flux&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;cumulative&#39;</span><span class="p">,</span> <span class="s1">&#39;fourier&#39;</span><span class="p">,</span> <span class="s1">&#39;Narray&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;magarray&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">Frac</span><span class="p">,</span> <span class="n">Flux</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">,</span> <span class="n">fourieroffset</span><span class="p">,</span> <span class="n">Narray</span><span class="p">,</span>
                                           <span class="n">magarray</span><span class="p">]):</span>
                        <span class="n">single_perturb_auf_output</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>
                    <span class="n">perturb_auf_outputs</span><span class="p">[</span><span class="n">perturb_auf_combo</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_perturb_auf_output</span>
                    <span class="k">continue</span>
                <span class="n">localN</span> <span class="o">=</span> <span class="n">calculate_local_density</span><span class="p">(</span>
                    <span class="n">a_astro_cut</span><span class="p">[</span><span class="n">good_mag_slice</span><span class="p">],</span> <span class="n">a_tot_astro</span><span class="p">,</span> <span class="n">a_tot_photo</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span>
                    <span class="n">auf_folder</span><span class="p">,</span> <span class="n">cat_folder</span><span class="p">,</span> <span class="n">density_radius</span><span class="p">,</span> <span class="n">dens_mags</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="c1"># Because we always calculate the density from the full</span>
                <span class="c1"># catalogue, using just the astrometry, we should be able</span>
                <span class="c1"># to just over-write this N times if there happen to be N</span>
                <span class="c1"># good detections of a source.</span>
                <span class="n">index_slice</span> <span class="o">=</span> <span class="n">med_index_slice</span><span class="p">[</span><span class="n">good_mag_slice</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_slice</span><span class="p">)):</span>
                    <span class="n">local_N</span><span class="p">[</span><span class="n">index_slice</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">localN</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="n">ax1_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ax1_min</span><span class="p">,</span> <span class="n">ax1_max</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
                <span class="n">ax2_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ax2_min</span><span class="p">,</span> <span class="n">ax2_max</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fit_gal_flag</span><span class="p">:</span>
                    <span class="n">single_perturb_auf_output</span> <span class="o">=</span> <span class="n">create_single_perturb_auf</span><span class="p">(</span>
                        <span class="n">ax_folder</span><span class="p">,</span> <span class="n">auf_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">filters</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">drho</span><span class="p">,</span> <span class="n">j0s</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">,</span>
                        <span class="n">psf_fwhms</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tri_filt_names</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dens_mags</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a_photo</span><span class="p">,</span> <span class="n">localN</span><span class="p">,</span> <span class="n">d_mag</span><span class="p">,</span>
                        <span class="n">delta_mag_cuts</span><span class="p">,</span> <span class="n">dd_params</span><span class="p">,</span> <span class="n">l_cut</span><span class="p">,</span> <span class="n">run_fw</span><span class="p">,</span> <span class="n">run_psf</span><span class="p">,</span> <span class="n">snr_mag_params</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                        <span class="n">al_avs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">auf_region_frame</span><span class="p">,</span> <span class="n">ax1_list</span><span class="p">,</span> <span class="n">ax2_list</span><span class="p">,</span> <span class="n">fit_gal_flag</span><span class="p">,</span> <span class="n">cmau_array</span><span class="p">,</span>
                        <span class="n">wavs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">z_maxs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nzs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha0</span><span class="p">,</span> <span class="n">alpha1</span><span class="p">,</span> <span class="n">alpha_weight</span><span class="p">,</span> <span class="n">ab_offsets</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                        <span class="n">filter_names</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">single_perturb_auf_output</span> <span class="o">=</span> <span class="n">create_single_perturb_auf</span><span class="p">(</span>
                        <span class="n">ax_folder</span><span class="p">,</span> <span class="n">auf_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">filters</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">drho</span><span class="p">,</span> <span class="n">j0s</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">,</span>
                        <span class="n">psf_fwhms</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tri_filt_names</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dens_mags</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a_photo</span><span class="p">,</span> <span class="n">localN</span><span class="p">,</span> <span class="n">d_mag</span><span class="p">,</span>
                        <span class="n">delta_mag_cuts</span><span class="p">,</span> <span class="n">dd_params</span><span class="p">,</span> <span class="n">l_cut</span><span class="p">,</span> <span class="n">run_fw</span><span class="p">,</span> <span class="n">run_psf</span><span class="p">,</span> <span class="n">snr_mag_params</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                        <span class="n">al_avs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">auf_region_frame</span><span class="p">,</span> <span class="n">ax1_list</span><span class="p">,</span> <span class="n">ax2_list</span><span class="p">,</span> <span class="n">fit_gal_flag</span><span class="p">)</span>
                <span class="n">perturb_auf_outputs</span><span class="p">[</span><span class="n">perturb_auf_combo</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_perturb_auf_output</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Without the simulations to force local normalising density N or</span>
                <span class="c1"># individual source brightness magnitudes, we can simply combine</span>
                <span class="c1"># all data into a single &quot;bin&quot;.</span>
                <span class="n">num_N_mag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># In cases where we do not want to use the perturbation AUF component,</span>
                <span class="c1"># we currently don&#39;t have separate functions, but instead set up dummy</span>
                <span class="c1"># functions and variables to pass what mathematically amounts to</span>
                <span class="c1"># &quot;nothing&quot; through the cross-match. Here we would use fortran</span>
                <span class="c1"># subroutines to create the perturbation simulations, so we make</span>
                <span class="c1"># f-ordered dummy parameters.</span>
                <span class="n">Frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_N_mag</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="n">Flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_N_mag</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="c1"># Remember that r is bins, so the evaluations at bin middle are one</span>
                <span class="c1"># shorter in length.</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_N_mag</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="c1"># Fix offsets such that the probability density function looks like</span>
                <span class="c1"># a delta function, such that a two-dimensional circular coordinate</span>
                <span class="c1"># integral would evaluate to one at every point, cf. ``cumulative``.</span>
                <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1"># The cumulative integral of a delta function is always unity.</span>
                <span class="n">cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_N_mag</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="c1"># The Hankel transform of a delta function is a flat line; this</span>
                <span class="c1"># then preserves the convolution being multiplication in fourier</span>
                <span class="c1"># space, as F(x) x 1 = F(x), similar to how f(x) * d(0) = f(x).</span>
                <span class="n">fourieroffset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_N_mag</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="c1"># Both normalising density and magnitude arrays can be proxied</span>
                <span class="c1"># with a dummy parameter, as any minimisation of N-m distance</span>
                <span class="c1"># must pick the single value anyway.</span>
                <span class="n">Narray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">magarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">single_perturb_auf_output</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                        <span class="p">[</span><span class="s1">&#39;frac&#39;</span><span class="p">,</span> <span class="s1">&#39;flux&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;cumulative&#39;</span><span class="p">,</span> <span class="s1">&#39;fourier&#39;</span><span class="p">,</span> <span class="s1">&#39;Narray&#39;</span><span class="p">,</span> <span class="s1">&#39;magarray&#39;</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">Frac</span><span class="p">,</span> <span class="n">Flux</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">,</span> <span class="n">fourieroffset</span><span class="p">,</span> <span class="n">Narray</span><span class="p">,</span> <span class="n">magarray</span><span class="p">]):</span>
                    <span class="n">single_perturb_auf_output</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>
                <span class="n">perturb_auf_outputs</span><span class="p">[</span><span class="n">perturb_auf_combo</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_perturb_auf_output</span>
            <span class="n">arraylengths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">perturb_auf_outputs</span><span class="p">[</span><span class="n">perturb_auf_combo</span><span class="p">][</span><span class="s1">&#39;Narray&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">include_perturb_auf</span><span class="p">:</span>
        <span class="n">longestNm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">arraylengths</span><span class="p">)</span>

        <span class="n">Narrays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">longestNm</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">filters</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">auf_points</span><span class="p">)),</span>
                          <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">magarrays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">longestNm</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">filters</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">auf_points</span><span class="p">)),</span>
                            <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">auf_points</span><span class="p">)):</span>
            <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">auf_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filters</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">arraylengths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">perturb_auf_combo</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">filters</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">Narray</span> <span class="o">=</span> <span class="n">perturb_auf_outputs</span><span class="p">[</span><span class="n">perturb_auf_combo</span><span class="p">][</span><span class="s1">&#39;Narray&#39;</span><span class="p">]</span>
                <span class="n">magarray</span> <span class="o">=</span> <span class="n">perturb_auf_outputs</span><span class="p">[</span><span class="n">perturb_auf_combo</span><span class="p">][</span><span class="s1">&#39;magarray&#39;</span><span class="p">]</span>
                <span class="n">Narrays</span><span class="p">[:</span><span class="n">arraylengths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Narray</span>
                <span class="n">magarrays</span><span class="p">[:</span><span class="n">arraylengths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">magarray</span>

    <span class="c1"># Once the individual AUF simulations are saved, we also need to calculate</span>
    <span class="c1"># the indices each source references when slicing into the 4-D cubes</span>
    <span class="c1"># created by [1-D array] x N-m combination x filter x sky position iteration.</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating perturbation AUFs filter indices for catalogue &quot;</span><span class="si">{}</span><span class="s1">&quot;...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">which_cat</span><span class="p">))</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">include_perturb_auf</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/con_cat_photo.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cat_folder</span><span class="p">))</span>
        <span class="n">localN</span> <span class="o">=</span> <span class="n">local_N</span>
    <span class="n">magref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/magref.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cat_folder</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">include_perturb_auf</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
            <span class="n">axind</span> <span class="o">=</span> <span class="n">modelrefinds</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">filterind</span> <span class="o">=</span> <span class="n">magref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">Nmind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">((</span><span class="n">localN</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">filterind</span><span class="p">]</span> <span class="o">-</span> <span class="n">Narrays</span><span class="p">[:</span><span class="n">arraylengths</span><span class="p">[</span><span class="n">filterind</span><span class="p">,</span> <span class="n">axind</span><span class="p">],</span>
                                                              <span class="n">filterind</span><span class="p">,</span> <span class="n">axind</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                              <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">filterind</span><span class="p">]</span> <span class="o">-</span> <span class="n">magarrays</span><span class="p">[:</span><span class="n">arraylengths</span><span class="p">[</span><span class="n">filterind</span><span class="p">,</span> <span class="n">axind</span><span class="p">],</span>
                                                           <span class="n">filterind</span><span class="p">,</span> <span class="n">axind</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">modelrefinds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Nmind</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># For the case that we do not use the perturbation AUF component,</span>
        <span class="c1"># our dummy N-m files are all one-length arrays, so we can</span>
        <span class="c1"># trivially index them, regardless of specifics.</span>
        <span class="n">modelrefinds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># The mapping of which filter to use is straightforward: simply pick</span>
    <span class="c1"># the filter index of the &quot;best&quot; filter for each source, from magref.</span>
    <span class="n">modelrefinds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">magref</span>

    <span class="k">if</span> <span class="n">delta_mag_cuts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_fracs</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># TODO: generalise once delta_mag_cuts is user-inputtable.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_fracs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">delta_mag_cuts</span><span class="p">)</span>
    <span class="c1"># Create the 4-D grids that house the perturbation AUF fourier-space</span>
    <span class="c1"># representation.</span>
    <span class="n">perturb_auf_outputs</span><span class="p">[</span><span class="s1">&#39;fourier_grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_auf_params_grid</span><span class="p">(</span>
        <span class="n">perturb_auf_outputs</span><span class="p">,</span> <span class="n">auf_points</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="s1">&#39;fourier&#39;</span><span class="p">,</span> <span class="n">arraylengths</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Create the estimated levels of flux contamination and fraction of</span>
    <span class="c1"># contaminated source grids.</span>
    <span class="n">perturb_auf_outputs</span><span class="p">[</span><span class="s1">&#39;frac_grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_auf_params_grid</span><span class="p">(</span>
        <span class="n">perturb_auf_outputs</span><span class="p">,</span> <span class="n">auf_points</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="s1">&#39;frac&#39;</span><span class="p">,</span> <span class="n">arraylengths</span><span class="p">,</span> <span class="n">n_fracs</span><span class="p">)</span>
    <span class="n">perturb_auf_outputs</span><span class="p">[</span><span class="s1">&#39;flux_grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_auf_params_grid</span><span class="p">(</span>
        <span class="n">perturb_auf_outputs</span><span class="p">,</span> <span class="n">auf_points</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="s1">&#39;flux&#39;</span><span class="p">,</span> <span class="n">arraylengths</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_perturb_auf</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">Narrays</span><span class="p">,</span> <span class="n">magarrays</span>

    <span class="k">return</span> <span class="n">modelrefinds</span><span class="p">,</span> <span class="n">perturb_auf_outputs</span></div>



<span class="k">def</span> <span class="nf">download_trilegal_simulation</span><span class="p">(</span><span class="n">tri_folder</span><span class="p">,</span> <span class="n">tri_filter_set</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">mag_num</span><span class="p">,</span> <span class="n">region_frame</span><span class="p">,</span>
                                 <span class="n">mag_lim</span><span class="p">,</span> <span class="n">min_area</span><span class="p">,</span> <span class="n">total_objs</span><span class="o">=</span><span class="mf">1.5e6</span><span class="p">,</span> <span class="n">AV</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma_AV</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get a single Galactic sightline TRILEGAL simulation of an appropriate sky</span>
<span class="sd">    size, and save it in a folder for use in the perturbation AUF simulations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tri_folder : string</span>
<span class="sd">        The location of the folder into which to save the TRILEGAL file.</span>
<span class="sd">    tri_filter_set : string</span>
<span class="sd">        The name of the filterset, as given by the TRILEGAL input form.</span>
<span class="sd">    ax1 : float</span>
<span class="sd">        The first axis position of the sightline to be simulated, in the frame</span>
<span class="sd">        determined by ``region_frame``.</span>
<span class="sd">    ax2 : float</span>
<span class="sd">        The second axis position of the TRILEGAL sightline.</span>
<span class="sd">    mag_num : integer</span>
<span class="sd">        The zero-indexed filter number in the ``tri_filter_set`` list of filters</span>
<span class="sd">        which decides the limiting magnitude down to which tosimulate the</span>
<span class="sd">        Galactic sources.</span>
<span class="sd">    region_frame : string</span>
<span class="sd">        Frame, either equatorial or galactic, of the cross-match being performed,</span>
<span class="sd">        indicating whether ``ax1`` and ``ax2`` are in Right Ascension and</span>
<span class="sd">        Declination or Galactic Longitude and Latitude.</span>
<span class="sd">    mag_lim : float</span>
<span class="sd">        Magnitude down to which to generate sources for the simulation.</span>
<span class="sd">    min_area : float</span>
<span class="sd">        Smallest requested area, based on the density of catalogue objects</span>
<span class="sd">        per unit area above specified brightness limits and a minimum</span>
<span class="sd">        acceptable number of simulated objects above those same limits.</span>
<span class="sd">    total_objs : integer, optional</span>
<span class="sd">        The approximate number of objects to simulate in a TRILEGAL sightline,</span>
<span class="sd">        affecting how large an area to request a simulated Galactic region of.</span>
<span class="sd">    AV : float, optional</span>
<span class="sd">        If specified, pass a pre-determined value of infinite-Av to the simulation</span>
<span class="sd">        API; otherwise pass its own &quot;default&quot; value and request it derive one</span>
<span class="sd">        internally.</span>
<span class="sd">    sigma_AV : float, optional</span>
<span class="sd">        If given, bypasses the default value specified in ~`macauff.get_trilegal`,</span>
<span class="sd">        setting the fractional scaling around `AV` in which to randomise</span>
<span class="sd">        extinction values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">class</span> <span class="nc">TimeoutException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">timeout_handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">TimeoutException</span>

    <span class="n">areaflag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">triarea</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_area</span><span class="p">)</span>
    <span class="n">tri_name</span> <span class="o">=</span> <span class="s1">&#39;trilegal_auf_simulation&#39;</span>
    <span class="n">galactic_flag</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">region_frame</span> <span class="o">==</span> <span class="s1">&#39;galactic&#39;</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="c1"># To avoid a loop where we start at some area, halve repeatedly until</span>
    <span class="c1"># the API call limit is satisfied, but then get nobjs &lt; total_objs and</span>
    <span class="c1"># try to scale back up again only to time out, only allow that to happen</span>
    <span class="c1"># if we haven&#39;t halved our area within the loop at all.</span>
    <span class="n">area_halved</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">areaflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">timeit</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;timeout&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nocomm_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;timeout&quot;</span> <span class="ow">or</span> <span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;nocomm&quot;</span><span class="p">:</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">timeout_handler</span><span class="p">)</span>
                <span class="c1"># Set a 11 minute &quot;timer&quot; to raise an error if get_trilegal takes</span>
                <span class="c1"># longer than, as this indicates the API call has run out of CPU</span>
                <span class="c1"># time on the other end. As get_trilegal has an internal &quot;busy&quot;</span>
                <span class="c1"># tone, we need to reset this alarm for each call, if we don&#39;t</span>
                <span class="c1"># get a &quot;good&quot; result from the function call.</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">alarm</span><span class="p">(</span><span class="mi">11</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>
                <span class="n">av_inf</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">get_trilegal</span><span class="p">(</span>
                    <span class="n">tri_name</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">folder</span><span class="o">=</span><span class="n">tri_folder</span><span class="p">,</span> <span class="n">galactic</span><span class="o">=</span><span class="n">galactic_flag</span><span class="p">,</span>
                    <span class="n">filterset</span><span class="o">=</span><span class="n">tri_filter_set</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="n">triarea</span><span class="p">,</span> <span class="n">maglim</span><span class="o">=</span><span class="n">mag_lim</span><span class="p">,</span> <span class="n">magnum</span><span class="o">=</span><span class="n">mag_num</span><span class="p">,</span> <span class="n">AV</span><span class="o">=</span><span class="n">AV</span><span class="p">,</span>
                    <span class="n">sigma_AV</span><span class="o">=</span><span class="n">sigma_AV</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;nocomm&quot;</span><span class="p">:</span>
                    <span class="n">nocomm_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># 11 minute timer allows for 5 loops of two-minute waits for</span>
                <span class="c1"># a response from the server.</span>
                <span class="k">if</span> <span class="n">nocomm_count</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">HTTPError</span><span class="p">(</span><span class="s2">&quot;TRILEGAL server has not communicated &quot;</span>
                                                        <span class="s2">&quot;in </span><span class="si">{}</span><span class="s2"> attempts.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nocomm_count</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">TimeoutException</span><span class="p">:</span>
            <span class="n">triarea</span> <span class="o">/=</span> <span class="mi">2</span>
            <span class="n">area_halved</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;TRILEGAL call time: </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Timed out, halving area&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;TRILEGAL call time: </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
            <span class="n">signal</span><span class="o">.</span><span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tri_folder</span><span class="p">,</span> <span class="n">tri_name</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># Two comment lines; one at the top and one at the bottom - we add a</span>
        <span class="c1"># third in a moment, however</span>
        <span class="n">nobjs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="c1"># If too few stars then increase by factor 10 and loop, or scale to give</span>
        <span class="c1"># about total_objs stars and come out of area increase loop --</span>
        <span class="c1"># simulations can&#39;t be more than 10 sq deg, so accept if that&#39;s as large</span>
        <span class="c1"># as we can go.</span>
        <span class="k">if</span> <span class="n">nobjs</span> <span class="o">&lt;</span> <span class="mi">10000</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">area_halved</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Too few numbers, increasing area...&quot;</span><span class="p">)</span>
            <span class="n">triarea</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">triarea</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">accept_results</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># If we can&#39;t multiple by 10 since we get to 10 sq deg area, then</span>
            <span class="c1"># we can just quit immediately since we can&#39;t do any better.</span>
            <span class="k">if</span> <span class="n">triarea</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">areaflag</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># If number counts are too low for either nobjs &lt; X comparison but</span>
        <span class="c1"># the area had to be reduced by 50% previously, just accept the area</span>
        <span class="c1"># we got, since it&#39;s basically the best the TRILEGAL API will provide.</span>
        <span class="k">elif</span> <span class="n">nobjs</span> <span class="o">&lt;</span> <span class="n">total_objs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">area_halved</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Scaling area to total_objs counts...&quot;</span><span class="p">)</span>
            <span class="n">triarea</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">triarea</span> <span class="o">/</span> <span class="n">nobjs</span> <span class="o">*</span> <span class="n">total_objs</span><span class="p">)</span>
            <span class="n">areaflag</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">accept_results</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sufficient counts or area halved, accepting run...&quot;</span><span class="p">)</span>
            <span class="n">areaflag</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">accept_results</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">accept_results</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm </span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tri_folder</span><span class="p">,</span> <span class="n">tri_name</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">accept_results</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;timeout&quot;</span>
        <span class="k">while</span> <span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;timeout&quot;</span><span class="p">:</span>
            <span class="n">av_inf</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">get_trilegal</span><span class="p">(</span>
                <span class="n">tri_name</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">folder</span><span class="o">=</span><span class="n">tri_folder</span><span class="p">,</span> <span class="n">galactic</span><span class="o">=</span><span class="n">galactic_flag</span><span class="p">,</span>
                <span class="n">filterset</span><span class="o">=</span><span class="n">tri_filter_set</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="n">triarea</span><span class="p">,</span> <span class="n">maglim</span><span class="o">=</span><span class="n">mag_lim</span><span class="p">,</span> <span class="n">magnum</span><span class="o">=</span><span class="n">mag_num</span><span class="p">,</span> <span class="n">AV</span><span class="o">=</span><span class="n">AV</span><span class="p">,</span>
                <span class="n">sigma_AV</span><span class="o">=</span><span class="n">sigma_AV</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tri_folder</span><span class="p">,</span> <span class="n">tri_name</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">contents</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;#area = </span><span class="si">{}</span><span class="s1"> sq deg</span><span class="se">\n</span><span class="s1">#Av at infinity = </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">triarea</span><span class="p">,</span> <span class="n">av_inf</span><span class="p">))</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tri_folder</span><span class="p">,</span> <span class="n">tri_name</span><span class="p">),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">calculate_local_density</span><span class="p">(</span><span class="n">a_astro</span><span class="p">,</span> <span class="n">a_tot_astro</span><span class="p">,</span> <span class="n">a_tot_photo</span><span class="p">,</span> <span class="n">auf_folder</span><span class="p">,</span> <span class="n">cat_folder</span><span class="p">,</span>
                            <span class="n">density_radius</span><span class="p">,</span> <span class="n">density_mag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculates the number of sources above a given brightness within a specified</span>
<span class="sd">    radius of each source in a catalogue, to provide a local density for</span>
<span class="sd">    normalisation purposes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a_astro : numpy.ndarray</span>
<span class="sd">        Sub-set of astrometric portion of total catalogue, for which local</span>
<span class="sd">        densities are to be calculated.</span>
<span class="sd">    a_tot_astro : numpy.ndarray</span>
<span class="sd">        Full astrometric catalogue, from which all potential sources above</span>
<span class="sd">        ``density_mag`` and coeval with ``a_astro`` sources are to be extracted.</span>
<span class="sd">    a_tot_photo : numpy.ndarray</span>
<span class="sd">        The photometry of the full catalogue, matching ``a_tot_astro``.</span>
<span class="sd">    auf_folder : string</span>
<span class="sd">        The folder designated to contain the perturbation AUF component related</span>
<span class="sd">        data for this catalogue.</span>
<span class="sd">    cat_folder : string</span>
<span class="sd">        The location of the catalogue files for this dataset.</span>
<span class="sd">    density_radius : float</span>
<span class="sd">        The radius, in degrees, out to which to consider the number of sources</span>
<span class="sd">        for the normalising density.</span>
<span class="sd">    density_mag : float</span>
<span class="sd">        The brightness, in magnitudes, above which to count sources for density</span>
<span class="sd">        purposes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    count_density : numpy.ndarray</span>
<span class="sd">        The number of sources per square degree near to each source in</span>
<span class="sd">        ``a_astro`` that are above ``density_mag`` in ``a_tot_astro``.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">min_lon</span><span class="p">,</span> <span class="n">max_lon</span> <span class="o">=</span> <span class="n">min_max_lon</span><span class="p">(</span><span class="n">a_astro</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">min_lat</span><span class="p">,</span> <span class="n">max_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a_astro</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a_astro</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="n">overlap_sky_cut</span> <span class="o">=</span> <span class="n">_load_rectangular_slice</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">a_tot_astro</span><span class="p">,</span> <span class="n">min_lon</span><span class="p">,</span> <span class="n">max_lon</span><span class="p">,</span> <span class="n">min_lat</span><span class="p">,</span> <span class="n">max_lat</span><span class="p">,</span>
                                              <span class="n">density_radius</span><span class="p">)</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="n">overlap_sky_cut</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a_tot_photo</span> <span class="o">&lt;=</span> <span class="n">density_mag</span><span class="p">)</span>
    <span class="n">a_astro_overlap_cut</span> <span class="o">=</span> <span class="n">a_tot_astro</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span>
    <span class="n">a_photo_overlap_cut</span> <span class="o">=</span> <span class="n">a_tot_photo</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span>

    <span class="n">ax1_loops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_lon</span><span class="p">,</span> <span class="n">max_lon</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
    <span class="c1"># Force the sub-division of the sky area in question to be 100 chunks, or</span>
    <span class="c1"># roughly square degree chunks, whichever is larger in area.</span>
    <span class="k">if</span> <span class="n">ax1_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ax1_loops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ax1_loops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_lon</span><span class="p">,</span> <span class="n">max_lon</span><span class="p">,</span>
                                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_lon</span> <span class="o">-</span> <span class="n">min_lon</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax2_loops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_lat</span><span class="p">,</span> <span class="n">max_lat</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax2_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ax2_loops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ax2_loops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_lat</span><span class="p">,</span> <span class="n">max_lat</span><span class="p">,</span>
                                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_lat</span> <span class="o">-</span> <span class="n">min_lat</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">full_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_astro</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ax1_start</span><span class="p">,</span> <span class="n">ax1_end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ax1_loops</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ax1_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">for</span> <span class="n">ax2_start</span><span class="p">,</span> <span class="n">ax2_end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ax2_loops</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ax2_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">small_sky_cut</span> <span class="o">=</span> <span class="n">_load_rectangular_slice</span><span class="p">(</span><span class="s1">&#39;small_&#39;</span><span class="p">,</span> <span class="n">a_astro</span><span class="p">,</span> <span class="n">ax1_start</span><span class="p">,</span> <span class="n">ax1_end</span><span class="p">,</span>
                                                    <span class="n">ax2_start</span><span class="p">,</span> <span class="n">ax2_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">a_astro_small</span> <span class="o">=</span> <span class="n">a_astro</span><span class="p">[</span><span class="n">small_sky_cut</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_astro_small</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">overlap_sky_cut</span> <span class="o">=</span> <span class="n">_load_rectangular_slice</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">a_astro_overlap_cut</span><span class="p">,</span> <span class="n">ax1_start</span><span class="p">,</span> <span class="n">ax1_end</span><span class="p">,</span>
                                                      <span class="n">ax2_start</span><span class="p">,</span> <span class="n">ax2_end</span><span class="p">,</span> <span class="n">density_radius</span><span class="p">)</span>
            <span class="n">cut</span> <span class="o">=</span> <span class="p">(</span><span class="n">overlap_sky_cut</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a_photo_overlap_cut</span> <span class="o">&lt;=</span> <span class="n">density_mag</span><span class="p">))</span>
            <span class="n">a_astro_overlap_cut_small</span> <span class="o">=</span> <span class="n">a_astro_overlap_cut</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_astro_overlap_cut_small</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">counts</span> <span class="o">=</span> <span class="n">paf</span><span class="o">.</span><span class="n">get_density</span><span class="p">(</span><span class="n">a_astro_small</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">a_astro_small</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                                         <span class="n">a_astro_overlap_cut_small</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                                         <span class="n">a_astro_overlap_cut_small</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">density_radius</span><span class="p">)</span>
                <span class="c1"># If objects return with zero bright sources in their error circle,</span>
                <span class="c1"># like in the else below we force at least themselves to be in the</span>
                <span class="c1"># circle, slightly over-representing any object below the</span>
                <span class="c1"># brightness cutoff, but 1/area is still a very low density.</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">full_counts</span><span class="p">[</span><span class="n">small_sky_cut</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If we have sources to check the surrounding density of, but</span>
                <span class="c1"># no bright sources around them, just set them to be alone</span>
                <span class="c1"># in the error circle, slightly over-representing bright objects</span>
                <span class="c1"># but still giving them a very low normalising sky density.</span>
                <span class="n">full_counts</span><span class="p">[</span><span class="n">small_sky_cut</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">min_lon</span><span class="p">,</span> <span class="n">max_lon</span> <span class="o">=</span> <span class="n">min_max_lon</span><span class="p">(</span><span class="n">a_astro_overlap_cut</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">min_lat</span><span class="p">,</span> <span class="n">max_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a_astro_overlap_cut</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a_astro_overlap_cut</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="n">circle_overlap_area</span> <span class="o">=</span> <span class="n">paf</span><span class="o">.</span><span class="n">get_circle_area_overlap</span><span class="p">(</span><span class="n">a_astro</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">a_astro</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">density_radius</span><span class="p">,</span>
                                                      <span class="n">min_lon</span><span class="p">,</span> <span class="n">max_lon</span><span class="p">,</span> <span class="n">min_lat</span><span class="p">,</span> <span class="n">max_lat</span><span class="p">)</span>

    <span class="n">count_density</span> <span class="o">=</span> <span class="n">full_counts</span> <span class="o">/</span> <span class="n">circle_overlap_area</span>

    <span class="k">del</span> <span class="n">cut</span>

    <span class="k">return</span> <span class="n">count_density</span>


<div class="viewcode-block" id="create_single_perturb_auf">
<a class="viewcode-back" href="../../api/macauff.create_single_perturb_auf.html#macauff.create_single_perturb_auf">[docs]</a>
<span class="k">def</span> <span class="nf">create_single_perturb_auf</span><span class="p">(</span><span class="n">tri_folder</span><span class="p">,</span> <span class="n">auf_point</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">drho</span><span class="p">,</span> <span class="n">j0s</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">,</span>
                              <span class="n">psf_fwhm</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">density_mag</span><span class="p">,</span> <span class="n">a_photo</span><span class="p">,</span> <span class="n">localN</span><span class="p">,</span> <span class="n">d_mag</span><span class="p">,</span> <span class="n">mag_cut</span><span class="p">,</span>
                              <span class="n">dd_params</span><span class="p">,</span> <span class="n">l_cut</span><span class="p">,</span> <span class="n">run_fw</span><span class="p">,</span> <span class="n">run_psf</span><span class="p">,</span> <span class="n">snr_mag_params</span><span class="p">,</span> <span class="n">al_av</span><span class="p">,</span>
                              <span class="n">region_frame</span><span class="p">,</span> <span class="n">ax1s</span><span class="p">,</span> <span class="n">ax2s</span><span class="p">,</span> <span class="n">fit_gal_flag</span><span class="p">,</span> <span class="n">cmau_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wav</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">z_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">ab_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates the associated parameters for describing a single perturbation AUF</span>
<span class="sd">    component, for a single sky position.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tri_folder : string</span>
<span class="sd">        Folder where the TRILEGAL datafile is stored, and where the individual</span>
<span class="sd">        filter-specific perturbation AUF simulations should be saved.</span>
<span class="sd">    auf_point : numpy.ndarray</span>
<span class="sd">        The orthogonal sky coordinates of the simulated AUF component.</span>
<span class="sd">    filt : float</span>
<span class="sd">        Filter for which to simulate the AUF component.</span>
<span class="sd">    r : numpy.ndarray</span>
<span class="sd">        Array of real-space positions.</span>
<span class="sd">    dr : numpy.ndarray</span>
<span class="sd">        Array of the bin sizes of each ``r`` position.</span>
<span class="sd">    rho : numpy.ndarray</span>
<span class="sd">        Fourier-space coordinates at which to sample the fourier transformation</span>
<span class="sd">        of the distribution of perturbations due to blended sources.</span>
<span class="sd">    drho : numpy.ndarray</span>
<span class="sd">        Bin widths of each ``rho`` coordinate.</span>
<span class="sd">    j0s : numpy.ndarray</span>
<span class="sd">        The Bessel Function of First Kind of Zeroth Order, evaluated at all</span>
<span class="sd">        ``r``-``rho`` combinations.</span>
<span class="sd">    num_trials : integer</span>
<span class="sd">        The number of realisations of blended contaminant sources to draw</span>
<span class="sd">        when simulating perturbations of source positions.</span>
<span class="sd">    psf_fwhm : float</span>
<span class="sd">        The full-width at half maxima of the ``filt`` filter.</span>
<span class="sd">    header : float</span>
<span class="sd">        The filter name, as given by the TRILEGAL datafile, for this simulation.</span>
<span class="sd">    density_mag : float</span>
<span class="sd">        The limiting magnitude above which to consider local normalising densities,</span>
<span class="sd">        corresponding to the ``filt`` bandpass.</span>
<span class="sd">    a_photo : numpy.ndarray</span>
<span class="sd">        The photometry of each source for which simulated perturbations should be</span>
<span class="sd">        made.</span>
<span class="sd">    localN : numpy.ndarray</span>
<span class="sd">        The local normalising densities for each source.</span>
<span class="sd">    d_mag : float</span>
<span class="sd">        The interval at which to bin the magnitudes of a given set of objects,</span>
<span class="sd">        for the creation of the appropriate brightness/density combinations to</span>
<span class="sd">        simulate.</span>
<span class="sd">    mag_cut : numpy.ndarray or list of floats</span>
<span class="sd">        The magnitude offsets -- or relative fluxes -- above which to keep track of</span>
<span class="sd">        the fraction of objects suffering from a contaminating source.</span>
<span class="sd">    dd_params : numpy.ndarray</span>
<span class="sd">        Polynomial fits for the various parameters controlling the background</span>
<span class="sd">        limited PSF-fit algorithm for centroid perturbations.</span>
<span class="sd">    l_cut : numpy.ndarray or list</span>
<span class="sd">        Relative flux cutoffs for which algorithm to use in the background</span>
<span class="sd">        limited PSF-fit algorithm case.</span>
<span class="sd">    run_fw : bool</span>
<span class="sd">        Flag indicating whether to run the &quot;flux-weighted&quot; version of the</span>
<span class="sd">        perturbation algorithm.</span>
<span class="sd">    run_psf : bool</span>
<span class="sd">        Flag indicating whether to run the &quot;background-dominated PSF&quot; version</span>
<span class="sd">        of the perturbation algorithm.</span>
<span class="sd">    snr_mag_params : numpy.ndarray</span>
<span class="sd">        Array, of shape ``(Y, 5)``, containing the pre-determined values of the</span>
<span class="sd">        magnitude-perturbation weighting relationship for a series of Galactic</span>
<span class="sd">        sightlines for this particular filter.</span>
<span class="sd">    al_av : float</span>
<span class="sd">        Reddening vector for the filter, :math:`\frac{A_\lambda}{A_V}`.</span>
<span class="sd">    region_frame : string</span>
<span class="sd">        Indicator as to whether we are in ``equatorial`` or ``galactic``</span>
<span class="sd">        coordinates.</span>
<span class="sd">    ax1s : list or numpy.ndarray of floats</span>
<span class="sd">        The unique longitudinal coordinates which, when combined with ``ax1s``,</span>
<span class="sd">        form a rectangular grid of extinctions to sample for model counts.</span>
<span class="sd">    ax2s : list or numpy.ndarray of floats</span>
<span class="sd">        Unique latitudinal coordinates to combine with ``ax1s`` for individual</span>
<span class="sd">        ra-dec or l-b pairings for which to simulate extinction-at-infinity.</span>
<span class="sd">    fit_gal_flag : bool</span>
<span class="sd">        Flag to indicate whether to simulate galaxy counts for the purposes of</span>
<span class="sd">        simulating the perturbation component of the AUF.</span>
<span class="sd">    cmau_array : numpy.ndarray, optional</span>
<span class="sd">        Array holding the c/m/a/u values that describe the parameterisation</span>
<span class="sd">        of the Schechter functions with wavelength, following Wilson (2022, RNAAS,</span>
<span class="sd">        6, 60) [1]_. Shape should be `(5, 2, 4)`, with 5 parameters for both blue</span>
<span class="sd">        and red galaxies.</span>
<span class="sd">    wav : float, optional</span>
<span class="sd">        Wavelength, in microns, of the filter of the current observations.</span>
<span class="sd">    z_max : float, optional</span>
<span class="sd">        Maximum redshift to simulate differential galaxy counts out to.</span>
<span class="sd">    nz : int, optional</span>
<span class="sd">        Number of redshifts to simulate, to dictate resolution of Schechter</span>
<span class="sd">        functions used to generate differential galaxy counts.</span>
<span class="sd">    alpha0 : list of numpy.ndarray or numpy.ndarray, optional</span>
<span class="sd">        Zero-redshift indices used to calculate Dirichlet SED coefficients,</span>
<span class="sd">        used within the differential galaxy count simulations. Should either be</span>
<span class="sd">        a two-element list or shape ``(2, 5)`` array. See [2]_ and [3]_ for</span>
<span class="sd">        more details.</span>
<span class="sd">    alpha1 : list of numpy.ndarray or numpy.ndarray, optional</span>
<span class="sd">        Dirichlet SED coefficients at z=1.</span>
<span class="sd">    alpha_weight : list of numpy.ndarray or numpy.ndarray, optional</span>
<span class="sd">        Weights used to derive the ``kcorrect`` coefficients within the</span>
<span class="sd">        galaxy count framework.</span>
<span class="sd">    ab_offset : float, optional</span>
<span class="sd">        The zero point difference between the chosen filter and the AB system,</span>
<span class="sd">        for conversion of simulated galaxy counts from AB magnitudes. Should</span>
<span class="sd">        be of the convention m = m_AB - ab_offset</span>
<span class="sd">    filter_name : string, optional</span>
<span class="sd">        The ``speclite`` style ``group_name-band_name`` name for the filter,</span>
<span class="sd">        for use in the creation of simulated galaxy counts.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    count_array : numpy.ndarray</span>
<span class="sd">        The simulated local normalising densities that were used to simulate</span>
<span class="sd">        potential perturbation distributions.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wilson T. J. (2022), RNAAS, 6, 60</span>
<span class="sd">    .. [2] Herbel J., Kacprzak T., Amara A., et al. (2017), JCAP, 8, 35</span>
<span class="sd">    .. [3] Blanton M. R., Roweis S. (2007), AJ, 133, 734</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># TODO: extend to allow a Galactic source model that doesn&#39;t depend on TRILEGAL</span>
    <span class="n">tri_name</span> <span class="o">=</span> <span class="s1">&#39;trilegal_auf_simulation&#39;</span>
    <span class="n">avs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ax1s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax2s</span><span class="p">)),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ax1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax1s</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ax2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax2s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">region_frame</span> <span class="o">==</span> <span class="s1">&#39;equatorial&#39;</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> <span class="n">dec</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s1">&#39;icrs&#39;</span><span class="p">)</span>
                <span class="n">l</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">galactic</span><span class="o">.</span><span class="n">l</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">galactic</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">degree</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span>
            <span class="n">AV</span> <span class="o">=</span> <span class="n">get_AV_infinity</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s1">&#39;galactic&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">avs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">AV</span>
    <span class="n">avs</span> <span class="o">=</span> <span class="n">avs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="p">(</span><span class="n">dens_hist_tri</span><span class="p">,</span> <span class="n">model_mags</span><span class="p">,</span> <span class="n">model_mag_mids</span><span class="p">,</span> <span class="n">model_mags_interval</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span>
     <span class="n">n_bright_sources_star</span><span class="p">)</span> <span class="o">=</span> <span class="n">make_tri_counts</span><span class="p">(</span>
        <span class="n">tri_folder</span><span class="p">,</span> <span class="n">tri_name</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">d_mag</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a_photo</span><span class="p">),</span> <span class="n">density_mag</span><span class="p">,</span> <span class="n">al_av</span><span class="o">=</span><span class="n">al_av</span><span class="p">,</span>
        <span class="n">av_grid</span><span class="o">=</span><span class="n">avs</span><span class="p">)</span>

    <span class="n">log10y_tri</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">dens_hist_tri</span><span class="p">)</span>
    <span class="n">log10y_tri</span><span class="p">[</span><span class="n">dens_hist_tri</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dens_hist_tri</span><span class="p">[</span><span class="n">dens_hist_tri</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">mag_slice</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_mags</span><span class="o">+</span><span class="n">model_mags_interval</span> <span class="o">&lt;=</span> <span class="n">density_mag</span><span class="p">)</span>
    <span class="n">tri_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">log10y_tri</span><span class="p">[</span><span class="n">mag_slice</span><span class="p">]</span> <span class="o">*</span> <span class="n">model_mags_interval</span><span class="p">[</span><span class="n">mag_slice</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">fit_gal_flag</span><span class="p">:</span>
        <span class="n">al_grid</span> <span class="o">=</span> <span class="n">al_av</span> <span class="o">*</span> <span class="n">avs</span>
        <span class="n">z_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">z_max</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
        <span class="n">gal_dens</span> <span class="o">=</span> <span class="n">create_galaxy_counts</span><span class="p">(</span><span class="n">cmau_array</span><span class="p">,</span> <span class="n">model_mag_mids</span><span class="p">,</span> <span class="n">z_array</span><span class="p">,</span> <span class="n">wav</span><span class="p">,</span> <span class="n">alpha0</span><span class="p">,</span> <span class="n">alpha1</span><span class="p">,</span>
                                        <span class="n">alpha_weight</span><span class="p">,</span> <span class="n">ab_offset</span><span class="p">,</span> <span class="n">filter_name</span><span class="p">,</span> <span class="n">al_grid</span><span class="p">)</span>
        <span class="n">gal_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gal_dens</span><span class="p">[</span><span class="n">mag_slice</span><span class="p">]</span> <span class="o">*</span> <span class="n">model_mags_interval</span><span class="p">[</span><span class="n">mag_slice</span><span class="p">])</span>
        <span class="n">log10y_gal</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">log10y_tri</span><span class="p">)</span>
        <span class="n">log10y_gal</span><span class="p">[</span><span class="n">gal_dens</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">gal_dens</span><span class="p">[</span><span class="n">gal_dens</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gal_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">log10y_gal</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">log10y_tri</span><span class="p">)</span>

        <span class="c1"># If we&#39;re not generating galaxy counts, we have to solely rely on</span>
        <span class="c1"># TRILEGAL counting statistics, so we only want to keep populated bins.</span>
        <span class="n">hc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dens_hist_tri</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">model_mag_mids</span> <span class="o">=</span> <span class="n">model_mag_mids</span><span class="p">[</span><span class="n">hc</span><span class="p">]</span>
        <span class="n">model_mags_interval</span> <span class="o">=</span> <span class="n">model_mags_interval</span><span class="p">[</span><span class="n">hc</span><span class="p">]</span>
        <span class="n">log10y_tri</span> <span class="o">=</span> <span class="n">log10y_tri</span><span class="p">[</span><span class="n">hc</span><span class="p">]</span>

    <span class="n">model_count</span> <span class="o">=</span> <span class="n">tri_count</span> <span class="o">+</span> <span class="n">gal_count</span>

    <span class="k">if</span> <span class="n">fit_gal_flag</span><span class="p">:</span>
        <span class="c1"># If we have both galaxies and stars to consider, both can be sufficiently</span>
        <span class="c1"># high number counts to make a valid model density. Simply scale the</span>
        <span class="c1"># number of simulated Galactic sources by the ratio of bright-magnitude</span>
        <span class="c1"># densities to get an effective &quot;number&quot; of galaxies.</span>
        <span class="n">n_bright_sources_gal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">gal_count</span> <span class="o">/</span> <span class="n">tri_count</span> <span class="o">*</span> <span class="n">n_bright_sources_star</span><span class="p">)</span>
        <span class="n">tot_n_bright_sources</span> <span class="o">=</span> <span class="n">n_bright_sources_star</span> <span class="o">+</span> <span class="n">n_bright_sources_gal</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># More straightforward, without any galaxy counts we simply check for</span>
        <span class="c1"># if we returned a good number of Galactic sources in our simulation.</span>
        <span class="n">tot_n_bright_sources</span> <span class="o">=</span> <span class="n">n_bright_sources_star</span>

    <span class="k">if</span> <span class="n">tot_n_bright_sources</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of simulated objects in this sky patch is too low to &quot;</span>
                         <span class="s2">&quot;reliably derive a model source density. Please include &quot;</span>
                         <span class="s2">&quot;more simulated objects.&quot;</span><span class="p">)</span>

    <span class="n">log10y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">log10y_tri</span> <span class="o">+</span> <span class="mi">10</span><span class="o">**</span><span class="n">log10y_gal</span><span class="p">)</span>

    <span class="c1"># Set a magnitude bin width of 0.25 mags, to avoid oversampling.</span>
    <span class="n">dmag</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">mag_min</span> <span class="o">=</span> <span class="n">dmag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a_photo</span><span class="p">)</span><span class="o">/</span><span class="n">dmag</span><span class="p">)</span>
    <span class="n">mag_max</span> <span class="o">=</span> <span class="n">dmag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a_photo</span><span class="p">)</span><span class="o">/</span><span class="n">dmag</span><span class="p">)</span>
    <span class="n">magbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mag_min</span><span class="p">,</span> <span class="n">mag_max</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">dmag</span><span class="p">)</span>
    <span class="c1"># For local densities, we want a percentage offset, given that we&#39;re in</span>
    <span class="c1"># logarithmic bins, accepting a log-difference maximum. This is slightly</span>
    <span class="c1"># lop-sided, but for 20% results in +18%/-22% limits, which is fine.</span>
    <span class="n">dlogN</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">logNvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">localN</span><span class="p">)</span>
    <span class="n">logN_min</span> <span class="o">=</span> <span class="n">dlogN</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">logNvals</span><span class="p">)</span><span class="o">/</span><span class="n">dlogN</span><span class="p">)</span>
    <span class="n">logN_max</span> <span class="o">=</span> <span class="n">dlogN</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">logNvals</span><span class="p">)</span><span class="o">/</span><span class="n">dlogN</span><span class="p">)</span>
    <span class="n">logNbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">logN_min</span><span class="p">,</span> <span class="n">logN_max</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">dlogN</span><span class="p">)</span>

    <span class="n">counts</span><span class="p">,</span> <span class="n">logNbins</span><span class="p">,</span> <span class="n">magbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">logNvals</span><span class="p">,</span> <span class="n">a_photo</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="n">logNbins</span><span class="p">,</span> <span class="n">magbins</span><span class="p">])</span>
    <span class="n">Ni</span><span class="p">,</span> <span class="n">magi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">mag_array</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">magbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">magbins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">magi</span><span class="p">]</span>
    <span class="n">count_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">logNbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">logNbins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">Ni</span><span class="p">])</span>

    <span class="n">R</span> <span class="o">=</span> <span class="mf">1.185</span> <span class="o">*</span> <span class="n">psf_fwhm</span>

    <span class="n">s_flux</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">mag_array</span><span class="p">)</span>
    <span class="n">lb_ind</span> <span class="o">=</span> <span class="n">mff</span><span class="o">.</span><span class="n">find_nearest_point</span><span class="p">(</span><span class="n">auf_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">auf_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">snr_mag_params</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">snr_mag_params</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="n">a_snr</span> <span class="o">=</span> <span class="n">snr_mag_params</span><span class="p">[</span><span class="n">lb_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">b_snr</span> <span class="o">=</span> <span class="n">snr_mag_params</span><span class="p">[</span><span class="n">lb_ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">c_snr</span> <span class="o">=</span> <span class="n">snr_mag_params</span><span class="p">[</span><span class="n">lb_ind</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">snr</span> <span class="o">=</span> <span class="n">s_flux</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c_snr</span> <span class="o">*</span> <span class="n">s_flux</span> <span class="o">+</span> <span class="n">b_snr</span> <span class="o">+</span> <span class="p">(</span><span class="n">a_snr</span> <span class="o">*</span> <span class="n">s_flux</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">B</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">dm_max</span> <span class="o">=</span> <span class="n">_calculate_magnitude_offsets</span><span class="p">(</span><span class="n">count_array</span><span class="p">,</span> <span class="n">mag_array</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span> <span class="n">model_mag_mids</span><span class="p">,</span> <span class="n">log10y</span><span class="p">,</span>
                                          <span class="n">model_mags_interval</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">model_count</span><span class="p">)</span>

    <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="mi">100000</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">paf</span><span class="o">.</span><span class="n">get_random_seed_size</span><span class="p">(),</span>
                                                        <span class="nb">len</span><span class="p">(</span><span class="n">count_array</span><span class="p">)))</span>

    <span class="n">psf_sig</span> <span class="o">=</span> <span class="n">psf_fwhm</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">run_fw</span><span class="p">:</span>
        <span class="n">Frac_fw</span><span class="p">,</span> <span class="n">Flux_fw</span><span class="p">,</span> <span class="n">fourieroffset_fw</span><span class="p">,</span> <span class="n">offset_fw</span><span class="p">,</span> <span class="n">cumulative_fw</span> <span class="o">=</span> <span class="n">paf</span><span class="o">.</span><span class="n">perturb_aufs</span><span class="p">(</span>
            <span class="n">count_array</span><span class="p">,</span> <span class="n">mag_array</span><span class="p">,</span> <span class="n">r</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dr</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">j0s</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">model_mag_mids</span><span class="p">,</span> <span class="n">model_mags_interval</span><span class="p">,</span> <span class="n">log10y</span><span class="p">,</span> <span class="n">model_count</span><span class="p">,</span>
            <span class="p">(</span><span class="n">dm_max</span><span class="o">/</span><span class="n">d_mag</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">mag_cut</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">psf_sig</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">dd_params</span><span class="p">,</span>
            <span class="n">l_cut</span><span class="p">,</span> <span class="s1">&#39;fw&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">run_psf</span><span class="p">:</span>
        <span class="n">Frac_psf</span><span class="p">,</span> <span class="n">Flux_psf</span><span class="p">,</span> <span class="n">fourieroffset_psf</span><span class="p">,</span> <span class="n">offset_psf</span><span class="p">,</span> <span class="n">cumulative_psf</span> <span class="o">=</span> <span class="n">paf</span><span class="o">.</span><span class="n">perturb_aufs</span><span class="p">(</span>
            <span class="n">count_array</span><span class="p">,</span> <span class="n">mag_array</span><span class="p">,</span> <span class="n">r</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dr</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">j0s</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">model_mag_mids</span><span class="p">,</span> <span class="n">model_mags_interval</span><span class="p">,</span> <span class="n">log10y</span><span class="p">,</span> <span class="n">model_count</span><span class="p">,</span>
            <span class="p">(</span><span class="n">dm_max</span><span class="o">/</span><span class="n">d_mag</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">mag_cut</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">psf_sig</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">dd_params</span><span class="p">,</span>
            <span class="n">l_cut</span><span class="p">,</span> <span class="s1">&#39;psf&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">run_fw</span> <span class="ow">and</span> <span class="n">run_psf</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">snr</span><span class="p">),</span> <span class="n">a_snr</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">snr</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">Flux</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">Flux_fw</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">Flux_psf</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Frac</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">Frac_fw</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">Frac_psf</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">offset_fw</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">offset_psf</span>
        <span class="n">cumulative</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">cumulative_fw</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">cumulative_psf</span>
        <span class="n">fourieroffset</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">fourieroffset_fw</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">fourieroffset_psf</span>
    <span class="k">elif</span> <span class="n">run_fw</span><span class="p">:</span>
        <span class="n">Flux</span> <span class="o">=</span> <span class="n">Flux_fw</span>
        <span class="n">Frac</span> <span class="o">=</span> <span class="n">Frac_fw</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_fw</span>
        <span class="n">cumulative</span> <span class="o">=</span> <span class="n">cumulative_fw</span>
        <span class="n">fourieroffset</span> <span class="o">=</span> <span class="n">fourieroffset_fw</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Flux</span> <span class="o">=</span> <span class="n">Flux_psf</span>
        <span class="n">Frac</span> <span class="o">=</span> <span class="n">Frac_psf</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_psf</span>
        <span class="n">cumulative</span> <span class="o">=</span> <span class="n">cumulative_psf</span>
        <span class="n">fourieroffset</span> <span class="o">=</span> <span class="n">fourieroffset_psf</span>

    <span class="n">single_perturb_auf_output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;frac&#39;</span><span class="p">,</span> <span class="s1">&#39;flux&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;cumulative&#39;</span><span class="p">,</span> <span class="s1">&#39;fourier&#39;</span><span class="p">,</span> <span class="s1">&#39;Narray&#39;</span><span class="p">,</span> <span class="s1">&#39;magarray&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">Frac</span><span class="p">,</span> <span class="n">Flux</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">,</span> <span class="n">fourieroffset</span><span class="p">,</span> <span class="n">count_array</span><span class="p">,</span> <span class="n">mag_array</span><span class="p">]):</span>
        <span class="n">single_perturb_auf_output</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>

    <span class="k">return</span> <span class="n">single_perturb_auf_output</span></div>



<span class="k">def</span> <span class="nf">make_tri_counts</span><span class="p">(</span><span class="n">trifolder</span><span class="p">,</span> <span class="n">trifilename</span><span class="p">,</span> <span class="n">trifiltname</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">brightest_source_mag</span><span class="p">,</span>
                    <span class="n">density_mag</span><span class="p">,</span> <span class="n">use_bright</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_faint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">al_av</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">av_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine TRILEGAL simulations for a given line of sight in the Galaxy, using</span>
<span class="sd">    both a &quot;bright&quot; simulation, with a brighter magnitude limit that allows for</span>
<span class="sd">    more detail in the lower-number statistic bins, and a &quot;faint&quot; or full</span>
<span class="sd">    simulation down to the faint limit to capture the full source count</span>
<span class="sd">    distribution for the filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trifolder : string</span>
<span class="sd">        Location on disk into which to save TRILEGAL simulations.</span>
<span class="sd">    trifilename : string</span>
<span class="sd">        Name to save TRILEGAL simulation files to, to which &quot;_bright&quot; and</span>
<span class="sd">        &quot;_faint&quot; will be appended for the two runs respectively.</span>
<span class="sd">    trifiltname : string</span>
<span class="sd">        The individual filter within ``trifilterset`` being used for generating</span>
<span class="sd">        differential source counts.</span>
<span class="sd">    dm : float</span>
<span class="sd">        Width of the bins into which to place simulated magnitudes.</span>
<span class="sd">    brightest_source_mag : float</span>
<span class="sd">        Magnitude in the appropriate ``trifiltname`` bandpass of the brightest</span>
<span class="sd">        source that these simulations are relevant for.</span>
<span class="sd">    density_mag : float</span>
<span class="sd">        The magnitude at which the counts of the corresponding dataset this</span>
<span class="sd">        TRILEGAL simulation is for turns over, suffering completeness limit</span>
<span class="sd">        effects.</span>
<span class="sd">    use_bright : boolean, optional</span>
<span class="sd">        Controls whether we load a &quot;bright&quot; set of TRILEGAL sources or not.</span>
<span class="sd">    use_faint : boolean, optional</span>
<span class="sd">        Determines whether we use a larger dynamic range, fainter TRILEGAL</span>
<span class="sd">        simulation to create a histogram of source counts.</span>
<span class="sd">    al_av : float, optional</span>
<span class="sd">        Differential extinction vector relative to the V-band. If given,</span>
<span class="sd">        ``av_grid`` must also be provided; together these will be used</span>
<span class="sd">        to manually extinct the TRILEGAL counts (assumed to be subject to zero</span>
<span class="sd">        reddening) to simulate differential extinction within the region.</span>
<span class="sd">    av_grid : numpy.ndarray, optional</span>
<span class="sd">        Grid of extinctions across the region TRILEGAL simulations are valid</span>
<span class="sd">        for. Must be provided if ``al_av`` is given.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dens : numpy.ndarray</span>
<span class="sd">        The probability density function of the resulting merged differential</span>
<span class="sd">        source counts from the two TRILEGAL simulations, weighted by their</span>
<span class="sd">        counting-statistic bin uncertainties.</span>
<span class="sd">    tri_mags : numpy.ndarray</span>
<span class="sd">        The left-hand bin edges of all bins used to generate ``dens``.</span>
<span class="sd">    tri_mags_mids : numpy.ndarray</span>
<span class="sd">        Middle of each bin generating ``dens``.</span>
<span class="sd">    dtri_mags : numpy.ndarray</span>
<span class="sd">        Bin widths of all bins corresponding to each element of ``dens``.</span>
<span class="sd">    uncert : numpy.ndarray</span>
<span class="sd">        Propagated Poissonian uncertainties of the PDF of ``dens``, using the</span>
<span class="sd">        weighted average of the individual uncertainties of each run for every</span>
<span class="sd">        bin in ``dens``.</span>
<span class="sd">    num_bright_obj : integer</span>
<span class="sd">        Number of simulated objects above the given ``density_mag`` brightness</span>
<span class="sd">        limit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_bright</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_faint</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;use_bright and use_faint cannot both be &#39;False&#39;.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">al_av</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">av_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">al_av</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">av_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If one of al_av or av_grid is provided the other must be given as well.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_faint</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">_faint.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trifolder</span><span class="p">,</span> <span class="n">trifilename</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">area_line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">av_line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># #area = {} sq deg, #Av at infinity = {} should be the first two lines, so</span>
        <span class="c1"># just split that by whitespace</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">area_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">tri_area_faint</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">av_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">tri_av_inf_faint</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">tri_av_inf_faint</span> <span class="o">&lt;</span> <span class="mf">0.1</span> <span class="ow">and</span> <span class="n">av_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tri_av_inf_faint cannot be smaller than 0.1 while using av_grid.&quot;</span><span class="p">)</span>
        <span class="n">tri_faint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">_faint.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trifolder</span><span class="p">,</span> <span class="n">trifilename</span><span class="p">),</span> <span class="n">delimiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                  <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="n">trifiltname</span><span class="p">,</span> <span class="s1">&#39;Av&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">use_bright</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">_bright.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trifolder</span><span class="p">,</span> <span class="n">trifilename</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">area_line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">av_line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">area_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">tri_area_bright</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">av_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">tri_av_inf_bright</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">tri_av_inf_bright</span> <span class="o">&lt;</span> <span class="mf">0.1</span> <span class="ow">and</span> <span class="n">av_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tri_av_inf_bright cannot be smaller than 0.1 while using av_grid.&quot;</span><span class="p">)</span>
        <span class="n">tri_bright</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">_bright.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trifolder</span><span class="p">,</span> <span class="n">trifilename</span><span class="p">),</span>
                                   <span class="n">delimiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                   <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="n">trifiltname</span><span class="p">,</span> <span class="s1">&#39;Av&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">use_faint</span><span class="p">:</span>
        <span class="n">tridata_faint</span> <span class="o">=</span> <span class="n">tri_faint</span><span class="p">[:][</span><span class="n">trifiltname</span><span class="p">]</span>
        <span class="n">tri_av_faint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">tri_faint</span><span class="p">[:][</span><span class="s1">&#39;Av&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">al_av</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">avs_faint</span> <span class="o">=</span> <span class="n">tri_faint</span><span class="p">[:][</span><span class="s1">&#39;Av&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">tri_faint</span>
    <span class="k">if</span> <span class="n">use_bright</span><span class="p">:</span>
        <span class="n">tridata_bright</span> <span class="o">=</span> <span class="n">tri_bright</span><span class="p">[:][</span><span class="n">trifiltname</span><span class="p">]</span>
        <span class="n">tri_av_bright</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">tri_bright</span><span class="p">[:][</span><span class="s1">&#39;Av&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">al_av</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">avs_bright</span> <span class="o">=</span> <span class="n">tri_bright</span><span class="p">[:][</span><span class="s1">&#39;Av&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">tri_bright</span>

    <span class="n">minmag</span> <span class="o">=</span> <span class="n">dm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">brightest_source_mag</span><span class="o">/</span><span class="n">dm</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_bright</span> <span class="ow">and</span> <span class="n">use_faint</span><span class="p">:</span>
        <span class="n">maxmag</span> <span class="o">=</span> <span class="n">dm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">tridata_faint</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">tridata_bright</span><span class="p">))</span><span class="o">/</span><span class="n">dm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">use_bright</span><span class="p">:</span>
        <span class="n">maxmag</span> <span class="o">=</span> <span class="n">dm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">tridata_bright</span><span class="p">)</span><span class="o">/</span><span class="n">dm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">use_faint</span><span class="p">:</span>
        <span class="n">maxmag</span> <span class="o">=</span> <span class="n">dm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">tridata_faint</span><span class="p">)</span><span class="o">/</span><span class="n">dm</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">al_av</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tri_mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minmag</span><span class="p">,</span> <span class="n">maxmag</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Pad the brightest magnitude (minmag) by the possibility of AV=0,</span>
        <span class="c1"># scaled to current reddening vector.</span>
        <span class="k">if</span> <span class="n">use_bright</span> <span class="ow">and</span> <span class="n">use_faint</span><span class="p">:</span>
            <span class="n">tri_mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minmag</span><span class="o">-</span><span class="n">al_av</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">tri_av_faint</span><span class="p">,</span> <span class="n">tri_av_bright</span><span class="p">),</span> <span class="n">maxmag</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">use_bright</span><span class="p">:</span>
            <span class="n">tri_mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minmag</span><span class="o">-</span><span class="n">al_av</span><span class="o">*</span><span class="n">tri_av_bright</span><span class="p">,</span> <span class="n">maxmag</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">use_faint</span><span class="p">:</span>
            <span class="n">tri_mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minmag</span><span class="o">-</span><span class="n">al_av</span><span class="o">*</span><span class="n">tri_av_faint</span><span class="p">,</span> <span class="n">maxmag</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
    <span class="n">tri_mags_mids</span> <span class="o">=</span> <span class="p">(</span><span class="n">tri_mags</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tri_mags</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_faint</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">al_av</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hist</span><span class="p">,</span> <span class="n">tri_mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">tridata_faint</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">tri_mags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tri_mags</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">av</span> <span class="ow">in</span> <span class="n">av_grid</span><span class="p">:</span>
                <span class="c1"># Take the ratio of AVs for scaling (i.e., if we&#39;d run TRILEGAL</span>
                <span class="c1"># with AV=1 but av_grid[0] = 2, we get 2x the extinction at each</span>
                <span class="c1"># distance we&#39;d otherwise have found. Or, if AV=1,</span>
                <span class="c1"># av_grid[1]=0.25, then we have a quarter the infinite-distance</span>
                <span class="c1"># extinction and hence 25% the extinction applied to the source.</span>
                <span class="n">av_ratio</span> <span class="o">=</span> <span class="n">av</span> <span class="o">/</span> <span class="n">tri_av_inf_faint</span>
                <span class="c1"># Apply the correction. Here if av_grid[i] = AV then we do</span>
                <span class="c1"># nothing; otherwise av_ratio = 2 gives an extra 100% AV,</span>
                <span class="c1"># and e.g. av_ratio = 0.25 subtracts three-quarters of the</span>
                <span class="c1"># applied AV value. These are scaled to the correct extinction</span>
                <span class="c1"># vector subsequently.</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">tridata_faint</span> <span class="o">+</span> <span class="p">(</span><span class="n">av_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">avs_faint</span> <span class="o">*</span> <span class="n">al_av</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">tri_mags</span><span class="p">)</span>
                <span class="n">hist</span> <span class="o">+=</span> <span class="n">y</span>
        <span class="n">hc_faint</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">&gt;</span> <span class="mi">3</span>
        <span class="n">dens_faint</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tri_mags</span><span class="p">)</span> <span class="o">/</span> <span class="n">tri_area_faint</span>
        <span class="n">dens_uncert_faint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tri_mags</span><span class="p">)</span> <span class="o">/</span> <span class="n">tri_area_faint</span>
        <span class="c1"># Account for summing NxM Avs here by dividing out len(av_grid).</span>
        <span class="k">if</span> <span class="n">av_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dens_faint</span> <span class="o">=</span> <span class="n">dens_faint</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">av_grid</span><span class="p">)</span>
            <span class="n">dens_uncert_faint</span> <span class="o">=</span> <span class="n">dens_uncert_faint</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">av_grid</span><span class="p">))</span>
        <span class="n">dens_uncert_faint</span><span class="p">[</span><span class="n">dens_uncert_faint</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e10</span>
        <span class="c1"># Now check whether there are sufficient sources at the bright end of</span>
        <span class="c1"># the simulation, counting the sources brighter than density_mag.</span>
        <span class="n">num_bright_obj_faint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="n">tri_mags</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">density_mag</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">av_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_bright_obj_faint</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">av_grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_bright</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">al_av</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hist</span><span class="p">,</span> <span class="n">tri_mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">tridata_bright</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">tri_mags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tri_mags</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">av</span> <span class="ow">in</span> <span class="n">av_grid</span><span class="p">:</span>
                <span class="n">av_ratio</span> <span class="o">=</span> <span class="n">av</span> <span class="o">/</span> <span class="n">tri_av_inf_bright</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">tridata_bright</span> <span class="o">+</span> <span class="p">(</span><span class="n">av_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">avs_bright</span> <span class="o">*</span> <span class="n">al_av</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">tri_mags</span><span class="p">)</span>
                <span class="n">hist</span> <span class="o">+=</span> <span class="n">y</span>
        <span class="n">hc_bright</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">&gt;</span> <span class="mi">3</span>
        <span class="n">dens_bright</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tri_mags</span><span class="p">)</span> <span class="o">/</span> <span class="n">tri_area_bright</span>
        <span class="n">dens_uncert_bright</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tri_mags</span><span class="p">)</span> <span class="o">/</span> <span class="n">tri_area_bright</span>
        <span class="k">if</span> <span class="n">av_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dens_bright</span> <span class="o">=</span> <span class="n">dens_bright</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">av_grid</span><span class="p">)</span>
            <span class="n">dens_uncert_bright</span> <span class="o">=</span> <span class="n">dens_uncert_bright</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">av_grid</span><span class="p">))</span>
        <span class="n">dens_uncert_bright</span><span class="p">[</span><span class="n">dens_uncert_bright</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e10</span>
        <span class="n">num_bright_obj_bright</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="n">tri_mags</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">density_mag</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">av_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_bright_obj_bright</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">av_grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_bright</span> <span class="ow">and</span> <span class="n">use_faint</span><span class="p">:</span>
        <span class="c1"># Assume that the number of objects in the bright dataset is truncated such</span>
        <span class="c1"># that it should be most dense at its faintest magnitude, and ignore cases</span>
        <span class="c1"># where objects may have &quot;scattered&quot; outside of that limit. These are most</span>
        <span class="c1"># likely to be objects in magnitudes that don&#39;t define the TRILEGAL cutoff,</span>
        <span class="c1"># where differential reddening can make a few of them slightly fainter than</span>
        <span class="c1"># average.</span>
        <span class="n">bright_cutoff_mag</span> <span class="o">=</span> <span class="n">tri_mags</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">hist</span><span class="p">)]</span>
        <span class="n">dens_uncert_bright</span><span class="p">[</span><span class="n">tri_mags</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">bright_cutoff_mag</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e10</span>
        <span class="n">w_f</span><span class="p">,</span> <span class="n">w_b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dens_uncert_faint</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dens_uncert_bright</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="p">(</span><span class="n">dens_bright</span> <span class="o">*</span> <span class="n">w_b</span> <span class="o">+</span> <span class="n">dens_faint</span> <span class="o">*</span> <span class="n">w_f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w_b</span> <span class="o">+</span> <span class="n">w_f</span><span class="p">)</span>
        <span class="n">dens_uncert</span> <span class="o">=</span> <span class="p">(</span><span class="n">dens_uncert_bright</span> <span class="o">*</span> <span class="n">w_b</span> <span class="o">+</span> <span class="n">dens_uncert_faint</span> <span class="o">*</span> <span class="n">w_f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w_b</span> <span class="o">+</span> <span class="n">w_f</span><span class="p">)</span>
        <span class="n">hc</span> <span class="o">=</span> <span class="n">hc_bright</span> <span class="o">|</span> <span class="n">hc_faint</span>

        <span class="n">num_bright_obj</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_bright_obj_faint</span><span class="p">,</span> <span class="n">num_bright_obj_bright</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">use_bright</span><span class="p">:</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">dens_bright</span>
        <span class="n">dens_uncert</span> <span class="o">=</span> <span class="n">dens_uncert_bright</span>
        <span class="n">hc</span> <span class="o">=</span> <span class="n">hc_bright</span>

        <span class="n">num_bright_obj</span> <span class="o">=</span> <span class="n">num_bright_obj_bright</span>
    <span class="k">elif</span> <span class="n">use_faint</span><span class="p">:</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">dens_faint</span>
        <span class="n">dens_uncert</span> <span class="o">=</span> <span class="n">dens_uncert_faint</span>
        <span class="n">hc</span> <span class="o">=</span> <span class="n">hc_faint</span>

        <span class="n">num_bright_obj</span> <span class="o">=</span> <span class="n">num_bright_obj_faint</span>

    <span class="n">dens</span> <span class="o">=</span> <span class="n">dens</span><span class="p">[</span><span class="n">hc</span><span class="p">]</span>
    <span class="n">dtri_mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tri_mags</span><span class="p">)[</span><span class="n">hc</span><span class="p">]</span>
    <span class="n">tri_mags_mids</span> <span class="o">=</span> <span class="n">tri_mags_mids</span><span class="p">[</span><span class="n">hc</span><span class="p">]</span>
    <span class="n">tri_mags</span> <span class="o">=</span> <span class="n">tri_mags</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">hc</span><span class="p">]</span>
    <span class="n">uncert</span> <span class="o">=</span> <span class="n">dens_uncert</span><span class="p">[</span><span class="n">hc</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">dens</span><span class="p">,</span> <span class="n">tri_mags</span><span class="p">,</span> <span class="n">tri_mags_mids</span><span class="p">,</span> <span class="n">dtri_mags</span><span class="p">,</span> <span class="n">uncert</span><span class="p">,</span> <span class="n">num_bright_obj</span>


<span class="k">def</span> <span class="nf">_calculate_magnitude_offsets</span><span class="p">(</span><span class="n">count_array</span><span class="p">,</span> <span class="n">mag_array</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span> <span class="n">model_mag_mids</span><span class="p">,</span> <span class="n">log10y</span><span class="p">,</span>
                                 <span class="n">model_mags_interval</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">N_norm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Derive minimum relative fluxes, or largest magnitude offsets, down to which</span>
<span class="sd">    simulated perturbers need to be simulated, based on both considerations of</span>
<span class="sd">    their flux relative to the noise of the primary object and the fraction of</span>
<span class="sd">    simulations in which there is no simulated perturbation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    count_array : numpy.ndarray</span>
<span class="sd">        Local normalising densities of simulations.</span>
<span class="sd">    mag_array : numpy.ndarray</span>
<span class="sd">        Magnitudes of central objects to have perturbations simulated for.</span>
<span class="sd">    B : float</span>
<span class="sd">        Fraction of ``snr`` the flux of the perturber should be; e.g. for</span>
<span class="sd">        1/20th ``B`` should be 0.05.</span>
<span class="sd">    snr : numpy.ndarray</span>
<span class="sd">        Theoretical signal-to-noise ratios of each object in ``mag_array``.</span>
<span class="sd">    model_mag_mids : numpy.ndarray</span>
<span class="sd">        Model magnitudes for simulated densities of background objects.</span>
<span class="sd">    log10y : numpy.ndarray</span>
<span class="sd">        log-10 source densities of simulated objects in the given line of sight.</span>
<span class="sd">    model_mags_interval : numpy.ndarray</span>
<span class="sd">        Widths of the bins for each ``log10y``.</span>
<span class="sd">    R : float</span>
<span class="sd">        Radius of the PSF of the given simulation, in arcseconds.</span>
<span class="sd">    N_norm : float</span>
<span class="sd">        Normalising local density of simulations, to scale to each</span>
<span class="sd">        ``count_array``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dm : numpy.ndarray</span>
<span class="sd">        Maximum magnitude offset required for simulations, based on SNR and</span>
<span class="sd">        empty simulation fraction.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Flim</span> <span class="o">=</span> <span class="n">B</span> <span class="o">/</span> <span class="n">snr</span>
    <span class="n">dm_max_snr</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Flim</span><span class="p">)</span>

    <span class="n">dm_max_no_perturb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">mag_array</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mag_array</span><span class="p">)):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">model_mag_mids</span> <span class="o">&gt;=</span> <span class="n">mag_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">model_mag_mids</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">log10y</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">*</span> <span class="n">model_mags_interval</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="o">/</span><span class="mi">3600</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">count_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">N_norm</span>

        <span class="c1"># Convolution of Poissonian distributions each with l_i is a Poissonian</span>
        <span class="c1"># with mean of sum_i l_i.</span>
        <span class="n">lamb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">_y</span><span class="p">)</span>
        <span class="c1"># CDF of Poissonian is regularised gamma Q(floor(k + 1), lambda), and we</span>
        <span class="c1"># want k = 0; we wish to find the dm that gives sufficiently large lambda</span>
        <span class="c1"># that k = 0 only occurs &lt;= x% of the time. If lambda is too small then</span>
        <span class="c1"># k = 0 is too likely. P(X &lt;= 0; lambda) = exp(-lambda).</span>
        <span class="c1"># For 1% chance of no perturber we want 0.01 = exp(-lambda); rearranging</span>
        <span class="c1"># lambda = -ln(0.01).</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lamb</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.01</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dm_max_no_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_x</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">mag_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In the case that we can&#39;t go deep enough in our simulated counts to</span>
            <span class="c1"># get &lt;1% chance of no perturber, just do the best we can.</span>
            <span class="n">dm_max_no_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mag_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">dm_max_snr</span><span class="p">,</span> <span class="n">dm_max_no_perturb</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dm</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../f-modindex.html" title="Fortran Module Index"
             >fortran modules</a> |</li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">macauff</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">macauff.perturbation_auf</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2022, Tom J Wilson.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>